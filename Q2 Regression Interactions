%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Test whether the SUVR–ASL (CBF/ATT) association differs by amyloid status (Y/N), per region
% Adapted from Q2 Regression Table
% 
% Region, mean_SUVR, Perfusion_Median, Arrival_Median, Amyloid_Status, Age, Voxel_Count
% For each Region × {CBF, ATT}, fits mean_SUVR ~ metric * INTERACTION TERM ; extracts pooled slope,
%       group-specific slopes (Negative/Positive), interaction term, 95% CIs, p-values, Adj_R2, DoF.
% Excel with per-region coefficients, CIs, p-values, interaction, Adj_R2, DoF.


clear all;
close all;
clc;

basedir = 'D:\Yasmin_Liz\Needed';
infile  = fullfile(basedir, 'averaged_by_region.xlsx');
outfile = fullfile(basedir, 'Q2regression_interaction_age.xlsx');

% --- Load data ---
data = readtable(infile);

% --- Ensure excel var names exist ----
reqVars = {'Region','mean_SUVR','Perfusion_Median','Arrival_Median','Amyloid_Status','Age','Voxel_Count'};
missing = setdiff(reqVars, data.Properties.VariableNames);
if ~isempty(missing)
    error('Missing required columns: %s', strjoin(missing, ', '));
end

% --- Make group categorical and set reference to 'Negative' when present ---
data.Amyloid_Status = categorical(string(data.Amyloid_Status));
if any(data.Amyloid_Status == "N")
    data.Amyloid_Status = reordercats(data.Amyloid_Status, ["N", setdiff(categories(data.Amyloid_Status),"N")]);
end

regions      = unique(data.Region);
metrics      = {'Perfusion_Median','Arrival_Median'};
metricLabels = {'CBF','ATT'};

% --- PREallocate results in a struct array ---
results = struct('Region',{},'Metric',{}, ...
    'Beta_Pooled',{},'CI_Pooled_L',{},'CI_Pooled_U',{},'p_Pooled',{}, ...
    'Beta_Neg',{},'CI_Neg_L',{},'CI_Neg_U',{},'p_Neg',{}, ...
    'Beta_Pos',{},'CI_Pos_L',{},'CI_Pos_U',{},'p_Pos',{}, ...
    'Beta_Interaction',{},'p_Interaction',{}, ...
    'Adj_R2',{},'DoF',{});

for m = 1:numel(metrics)
    metric = metrics{m};
    label  = metricLabels{m};

    for r = 1:numel(regions)
        region = regions{r};
        sub = data(strcmp(data.Region, region), :);

% --- omit rows with missing  vars ---
        sub = rmmissing(sub(:, {'mean_SUVR', metric, 'Amyloid_Status', 'Age', 'Voxel_Count'}));
        if height(sub) < 6
            % too few data points to fit reliably
            continue;
        end

% --- Fit interaction model with covariates ---
        form = sprintf('mean_SUVR ~ %s * Amyloid_Status', metric);
        mdl  = fitlm(sub, form);

        % Coefficient table & covariance
        coefTbl = mdl.Coefficients;
        covB    = mdl.CoefficientCovariance;
        df      = mdl.DFE;

% --- N is reference; non-reference is Y ---
      iMetric   = find(strcmp(coefTbl.Properties.RowNames, metric));
      interName = sprintf('%s:Amyloid_Status_Y', metric);
      iInter    = find(strcmp(coefTbl.Properties.RowNames, interName));


% --- If rows missing ---
        if isempty(iMetric)
            continue;
        end

% --- Pooled slope (metric main effect) ----
        beta_pool = coefTbl.Estimate(iMetric);
        p_pool    = coefTbl.pValue(iMetric);
        CI_all    = coefCI(mdl);  % 95% CI for all coefficients
        CI_pool   = CI_all(iMetric, :);

% --- Interaction (difference in slopes) ---
        if ~isempty(iInter)
            beta_int = coefTbl.Estimate(iInter);
            p_int    = coefTbl.pValue(iInter);
        else
            beta_int = NaN; p_int = NaN;
        end

% --- Group-specific slopes ---
% --- Negative group slope = main effect of metric (reference group) ---
        beta_neg = beta_pool;
% --- Positive group slope = main effect + interaction ---
        beta_pos = beta_pool + beta_int;

% --- p-value for Negative slope is same as main-effect p
        p_neg = p_pool;

% --- p-value for Positive slope: test H0: (metric + interaction) = 0
% --- Build contrast vector c'*beta
        p_pos = NaN;
        if ~isempty(iInter)
            c = zeros(1, height(coefTbl));
            c(iMetric) = 1;
            c(iInter)  = 1;
            % coefTest returns F-stat for 1-df test; get p from that
            F = coefTest(mdl, c);
            p_pos = fcdf(F, 1, df, 'upper'); % right-tail p-value
        end

% --- 95% CI for Negative slope is CI of main effect ---
        CI_neg = CI_pool;

%  --- 95% CI for Positive slope via delta method: ---
        CI_pos = [NaN NaN];
        if ~isempty(iInter)
            % var(a+b) = var(a)+var(b)+2*cov(a,b)
            var_pos = covB(iMetric,iMetric) + covB(iInter,iInter) + 2*covB(iMetric,iInter);
            se_pos  = sqrt(var_pos);
            tcrit   = tinv(0.975, df);
            CI_pos  = [beta_pos - tcrit*se_pos, beta_pos + tcrit*se_pos];
        end

% --- Store ---
        results(end+1) = struct( ...
            'Region',          string(region), ...
            'Metric',          string(label), ...
            'Beta_Pooled',     beta_pool, ...
            'CI_Pooled_L',     CI_pool(1), ...
            'CI_Pooled_U',     CI_pool(2), ...
            'p_Pooled',        p_pool, ...
            'Beta_Neg',        beta_neg, ...
            'CI_Neg_L',        CI_neg(1), ...
            'CI_Neg_U',        CI_neg(2), ...
            'p_Neg',           p_neg, ...
            'Beta_Pos',        beta_pos, ...
            'CI_Pos_L',        CI_pos(1), ...
            'CI_Pos_U',        CI_pos(2), ...
            'p_Pos',           p_pos, ...
            'Beta_Interaction',beta_int, ...
            'p_Interaction',   p_int, ...
            'Adj_R2',          mdl.Rsquared.Adjusted, ...
            'DoF',             df ...
        );
    end
end

% --- Convert and write ---
if isempty(results)
    warning('No results produced (check data filtering).');
else
    T = struct2table(results);
    % Optional: sort by Region then Metric
    T = sortrows(T, {'Region','Metric'});
    writetable(T, outfile);
    fprintf('Saved: %s\n', outfile);
end
